# 面向对象的特征方面有哪些?

1.抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一
       部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。
       (抽象方法是一种没有实现的方法，在应用程序中使用抽象类的唯一方法是继承这个类。它的子类如果不能再次声明抽象，那么可以实例化。子类继承
       超类的行为，子类可以实现抽象方法)
       
2.继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称
       为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法
       和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。    
       
3.封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、
       封装的对象，这些对象通过一个受保护的接口访问其他对象。 (将类的某些信息隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的
       方法实现对隐藏信息的操作和访问)

4.多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的
         优势，很好的解决了应用程序函数同名问题。
         Animal obj1 = new Animal();   //父类的引用可以指向本类的对象
         Animal obj2  = new Dog();     //父类的引用也可以指向子类的对象



# 抽象类和接口间的关系

1. 接口所有方法都具有public 和abstract。

2. 接口不能有完全定义的方法。根据定义，接口仅用于提供契约。
    抽象类可以有非抽象的方法，没有任何限制。您可以使用任何非抽象方法的关键字，就像在其他类中一样。

3. 任何抽象类可以用extends关键字继承抽象类，用implements关键字实现接口。
    一个类只能继承一个类，但可以实现任意数量的接口。Java用此特性模拟多继承。(抽象类只能实现一次，接口可多次实现)

4. 接口是完全抽象的，不能被实例化；Java抽象类也不能实例化，但可以被调用，如果main()存在。


# 抽象类和接口的区别：

1. 抽象类只能被继承，而且只能单继承。
   接口需要被实现，而且可以多实现。

2. 抽象类中可以定义非抽象方法，子类可以直接继承使用。
   接口中都是抽象方法，需要子类去实现。

3. 抽象类使用的是 is a 关系。
   接口使用的 like a 关系。

4. 抽象类的成员修饰符可以自定义。
   接口中的成员修饰符是固定的。全都是public的。
   



# String是最基本的数据类型吗?

  基本数据类型包括byte、int、char、long、float、double、boolean和short  //数值型，字符型，布尔型 （这些存储时存储数据本身）
  java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类
  所以String不是最基本的数据类型，而是引用数据类型，与此类似的还有 类 接口 数组  （这些存储时存储的是数据的空间地址）



# int 和 Integer 有什么区别

  java中提供两种数据类型分别为 基本数据类型（int,byte,short,long...） 引用数据类型 (Integer String Double)
  int 是 java 的原始数据类型, Integer 是 java 为 int 提供的封装类    //Java为每个原始类型提供了封装类
  
  原始类型封装类booleanBoolean  charCharacter  byteByte  shortShort  intInteger  longLong  floatFloat  doubleDouble
  
  引用类型和原始类型的行为完全不同，并且他们具有不同的意义，引用类型和原始类型具有不同的特征和用法，包括 1.大小和速度问题，2.这种类型
  以哪种类型的数据结构存储  3.当引用类型和原始类型用作某个类的实例数据时所指定的缺省值 
  //对象引用实例变量的缺省值为null，原始数据引用实例变量的缺省值跟原始数据的具体类型有关



# String 和StringBuffer的区别
  
  它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修
  改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。
  
  
  
# 说出Servlet的生命周期，并说出Servlet和CGI的区别

  Servlet被服务器实例化后，容器运行其init方法（初始化）,请求到达时运行其service方法，service方法自动派遣运行与请求对应的
  （doGET||doPOST）方法，当服务器决定将实例销毁的时候就用destory()方法。
  
  与cgi的区别是servlet处于服务器进程中，它通过多线程方式运行其service方法,一个实例可以服务于多个请求，并且其实例一般不会被销毁，而cgi
  对每个请求都会产生新的进程，服务完成后就会销毁，效率上低于Servlet。
  
  
  
# Thread类中run()和start()方法的区别：

    start()：用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类
             的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里
             方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。

    run()：run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要
           顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。

    总结：start()方法最本质的功能是从CPU中申请另一个线程空间来执行 run()方法中的代码,它和当前的线程是两条线,在相对独立的线程空间运行,
         也就是说,如果你直接调用线程对象的run()方法,当然也会执行,但那是 在当前线程中执行,run()方法执行完成后继续执行下面的代码.而调用
         start()方法后,run()方法的代码会和当前线程并发(单CPU)或并行 (多CPU)执行。所以请记住一句话：调用线程对象的run方法不会产生一个
         新的线程，虽然可以达到相同的执行结果,但执行过程和执行效率不同.
         
         
         
         
# 堆，栈的存储

  堆区：只存放类对象，线程共享；
  方法区：又叫静态存储区，存放class文件和静态数据，线程共享;
  栈区：存放方法局部变量，基本类型变量区、执行环境上下文、操作指令区，线程不共享;
  
  
# Get\Post 区别
  他们都是基于http协议的,http底层是TCP/IP协议,本质上是TCP链接，并无区别，但是由于HTTP的规定和浏览器/服务器的限制，导致他们在使用过程中会
  出现一些不同(GET/POST只是标签，TCP才是GET和POST实现的根本)
  GET产生一个TCP数据包；POST产生两个TCP数据包
  对于GET请求，直接将http header和data发送出去，服务器响应200
  对于POST请求，首先将header发送，服务器响应的100 continue, 然后继续发送data, 服务器响应200 ok
  (开车运货，get只发一次车，post先说，我要开车了，然后继续送货)
  关于两者之间的坑,看起来显然是get请求好一点,Actually,
  1.不是所有的浏览器的POST都会发送2个包,FireFox每次发送两个包
  2.网络环境好时，差别基本可忽略，网络差时，post更能保证数据的准确性
  3.它们都有自己的语义，不能混用
  







